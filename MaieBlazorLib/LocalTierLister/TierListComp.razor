@page "/tier"
@using System.Globalization
@using System.Collections
@using Microsoft.Extensions.Logging
@using MudBlazor
@using Microsoft.AspNetCore.Components.Web.Virtualization
@inject ILogger<TierListComp> Logger
@inject IJSRuntime JSRuntime
<link href="css/charactercolor.css" rel="stylesheet" />

<div style="overflow: hidden">
	<div class="col-12 d-flex darken-50 flex-column text-light m-0 m-md-2 rounded">
		<div class="d-flex flex-wrap flex-fill flex-row rounded">
			<input type="text" class="spinput rounded col-4 flex-fill me-2 text-light p-2" @bind="@selected.name" placeholder="Tierlist Name">
			<div class="row col-sm-4 col-md-3 col-lg-2 mx-2 my-1 d-flex flex-fill flex-wrap">
				<div class="row p-0 col-12 d-flex">
					<div class="d-flex col-12 p-0 flex-nowrap flex-fill flex-row">
						<h5 class="clickable flex-fill p-2 m-0 text-center rounded btn bg-primary align-content-center" @onclick="Export"> Export Tierlist </h5>
					</div>
				</div>
			</div>
			<MudTextField @bind-Value="filter" Placeholder="Search" Immediate="true" Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="m-0 mt-2 mx-2 p-0 text-light"></MudTextField>
			
			@if (!showcase)
			{
				<h5 class="clickable flex-fill p-2 m-2 text-center rounded btn bg-highlight align-content-center" @onclick="() => Toggle(ref TierEdit)"> Edit Tiers </h5>
            }
		</div>
		@foreach (var pair in selected.tiers)
		{
			<div class="p-0 m-0 d-flex darken-25 flex-md-row @(minimal ? "flex-sm-row" : "flex-column") col-12"
				 data-tier-id="@pair.Key">
				<a class="text-box-container d-flex clickable text-center justify-content-center @(minimal ? "col-1 flex-row" : "flex-row") align-items-center py-1 py-sm-1 py-md-auto me-1" @onmousedown="(e) => SelectTier(e, pair.Key)" style="background-color: @pair.Value.color">
					<input type="text" value="@pair.Value.name" class="tierput rounded d-flex py-md-auto p-1 m-0 flex-fill text-wrap overflow-visible text-break text-light" @onchange="(e) => ChangeTierName(e.Value?.ToString(), pair.Key)" placeholder="Tier Title" style="@GetFontSize(pair.Value.name); white-space: normal; word-wrap: break-word; overflow-wrap: break-word;">
					@*<MudTextField @bind-Value="pair.Value.name" T="string" Text="@pair.Value.name" Variant="Variant.Outlined" @onblur="() => ChangeTierName(pair.Value)" AutoGrow Lines="4" Class="d-flex flex-column text-center justify-content-center text-light border-0" Style="@GetFontSize(pair.Value.name)"></MudTextField>*@
				</a>
				@*<a id="pair.Value.name" class="text-box-container d-flex clickable flex-column text-center justify-content-center col-sm-1 py-1 py-sm-1 py-md-auto me-1" @onmousedown="(e) => SelectTier(e, pair.Key)" style="background-color: @pair.Value.color">
					<p contenteditable="plaintext-only" class="tierput rounded d-flex flex-column py-md-auto justify-content-center p-1 m-0 flex-fill text-center text-wrap overflow-hidden text-break text-light" @oninput="(e) => StoreTierName(e)" @onblur="(e) => ChangeTierName(e, pair.Key)" placeholder="Tier Title" style="@GetFontSize(pair.Value.name);">@pair.Value.name</p>
				</a>*@
				@*<textarea class="tierput col-sm-1 clickable rounded d-flex py-md-auto py-1 m-0 flex-column overflow-hidden px-auto justify-content-center flex-fill text-center text-light" 
					@onmousedown="(e) => SelectTier(e, pair.Key)" @onchange="(e) => ChangeTierName(e.Value?.ToString(), pair.Key)" 
					style="background-color: @pair.Value.color; @GetFontSize(pair.Value.name); resize: none; text-align-last: center">
					@pair.Value.name
				</textarea>*@
				 

				<a class="d-flex flex-fill col-12 text-light" 
				@ondrop="() => DropIntoTier(pair.Key)" 
				@ondragover="() => OverTier(pair.Key)" 
				@ondragover:preventDefault="true" 
				@onpointermove="(e) => OnPointerMove(e, pair)"
				@ondragleave="OuttaTier">
					<div class="d-flex text-start flex-wrap col-12" style="border-top: solid; border-bottom: solid; border-color: @pair.Value.color">
						<Virtualize Items="GetFilteredItems(pair.Value)" ItemSize="100" TItem="TierItem">
							<ItemContent Context="item">
								@{
									// compute index only when needed (IndexOf is O(n) but Virtualize limits rendered items)
									var idx = pair.Value.items.IndexOf(item);
								}
								@if (showcase)
								{
									<MudTooltip class="col-2" Color="Color.Transparent">
										<ChildContent>
											<TierItemComp item="@item" id="@idx" isminimal="@minimal" NoImage="@NoImg" OverStyle="@(item == DragDropApi<TierItem>.GetOver())"
												OnItemSelect="Select"
												OnItemDrag="() => DragDropApi<TierItem>.StartDrag(pair.Value.items, idx)"
												OnItemDragStop="StopDrag"
												OnItemOver="() => DragDropApi<TierItem>.OverHere(pair.Value.items, idx)"
												OnItemOut="DragDropApi<TierItem>.OuttaHere"></TierItemComp>
										</ChildContent>
										<TooltipContent>
											<div class="text-light darken-95 rounded p-3 m-0">
												@item.name
											</div>
										</TooltipContent>
									</MudTooltip>
								}
								else
								{
									<TierItemComp @key="item" item="@item" id="@idx" isminimal="@minimal" NoImage="@NoImg" OverStyle="@(item == DragDropApi<TierItem>.GetOver())"
										OnItemSelect="Select"
										OnItemDrag="() => DragDropApi<TierItem>.StartDrag(pair.Value.items, idx)"
										OnItemDragStop="StopDrag"
										OnItemOver="() => DragDropApi<TierItem>.OverHere(pair.Value.items, idx)"
										OnItemOut="DragDropApi<TierItem>.OuttaHere"></TierItemComp>
								}
							</ItemContent>
						</Virtualize>
						@if (!showcase)
						{
							if (minimal)
							{
								<h5 class="clickable p-0 m-1 justify-content-center rounded px-auto text-center d-flex flex-column template tieritemsmall" @onclick="() => Add(pair.Key)"> New Item </h5>
							}
							else
							{
								<h5 class="clickable p-0 m-0 justify-content-center py-auto rounded text-center my-auto d-flex flex-column template tieritem" @onclick="() => Add(pair.Key)"> New Item </h5>
							}
						}
					</div>
				</a>
			</div>
		}
		<div class="d-flex darken-25 col-12 flex-row m-0 p-0">
			@if (!showcase)
			{
				<a class="clickable col-12 p-0 m-0" @onclick="NewTier">
					<div class="d-block tieritem py-auto p-0 m-0 text-center template col-1 me-1 py-auto bg-darken-25">
						<h2>New Tier</h2>
					</div>
				</a>
				<div class="d-flex col-11"></div>
			}
		</div>
	</div>

	<!-------------  MODALS  ------------>
	@if (selecitem != null)
	{
		<div class="maiedal">
			<div class="d-flex col-12 ol-md-8 rounded darken-95 flex-column mx-auto my-auto shadow">
				<div class="d-flex p-4 text-end justify-content-end">
					<a class="clickable" @onclick="Exit">✖</a>
				</div>
				<img class="text-center d-flex mx-auto my-2" src="@selecitem.img" style="max-height: 400px; max-width: 400px" />
				<input type="text" class="spinput rounded flex-fill text-light mx-2 p-2" @bind="@selecitem.name" placeholder="Item Name">
				<input type="text" class="spinput rounded flex-fill text-light mx-2 p-2" @bind="@selecitem.img" placeholder="Image Link">
				<input type="text" class="spinput rounded flex-fill text-light mx-2 p-2" @bind="@selecitemtags" @bind:after="UpdateTags" placeholder="Tags (separated by comma)">
				<input type="text" class="spinput rounded flex-fill text-light mx-2 p-3" @bind="@selecitem.notes" placeholder="Additional Notes">
				<button class="bg-danger rounded m-2 p-1" @onclick="YouSure">Remove</button>
			</div>
		</div>
		@if (yousure)
		{
			<div class="maiedal d-flex flex-column text-center justify-content-center">
				<div class="p-2 darken-95 d-flex rounded text-center flex-column justify-content-center mx-auto text-light col-10 col-md-6 border-2 shadow border-light">
					<p> Are you sure you want to permanently remove this item? </p>
					<div class="d-flex flex-row flex-wrap mx-auto">
						<button class="mx-2 text-light" @onclick="YouSure">No</button>
						<button class="mx-2 rounded p-1 bg-danger" @onclick="Delete">Yes, remove it</button>
					</div>
				</div>
			</div>
		}
	}
	
	@if (selectier != null)
	{
		<div class="maiedal">
			<div class="p-0 p-md-2 d-flex col-12 col-md-8 rounded darken-95 flex-column mx-auto my-auto">
				<div class="d-flex p-2 text-end justify-content-end">
					<a class="clickable" @onclick="Exit">✖</a>
				</div>
				<div class="d-flex flex-column text-center justify-content-center mx-auto col-sm-1 py-1 py-sm-1 py-md-auto">
					<input type="text" value="@selectier.name" class="rounded fs-2 py-md-auto py-1 m-0 text-center flex-fill col-12 text-wrap text-light" @onchange="(e) => ChangeTierName(e.Value?.ToString(), selectier.ogname)" placeholder="Tier Title" style="background-color: @selectier.color">
				</div>
				<MudColorPicker Label="Tier Color" @bind-Text="selectier.color" Style="@($"color: {selectier.color};")" Placeholder="Select Color" />
				<button class="mx-2 text-danger" @onclick="YouSure">Remove</button>
			</div>
		</div>
		@if (yousure)
		{
			<div class="maiedal d-flex flex-column text-center justify-content-center">
				<div class="p-0 p-md-2 darken-95 d-flex rounded text-center flex-column justify-content-center mx-auto text-light col-6">
					<h5> Are you sure you want to permanently remove this tier? All items will be deleted with it!</h5>
					<div class="d-flex flex-row flex-wrap mx-auto">
						<button class="mx-2 text-light" @onclick="YouSure">No</button>
						<button class="mx-2 text-danger" @onclick="DeleteTier">Yes, remove it and all items within</button>
					</div>
				</div>
			</div>
		}
	}
	
	@if (TierEdit)
	{
		<div class="maiedal">
			<div class="p-2 d-flex col-12 col-md-8 rounded darken-95 flex-column mx-auto my-auto">
				<div class="d-flex p-2 text-end justify-content-end">
					<a class="clickable" @onclick="Exit">✖</a>
				</div>
				@foreach (var pair in selected.tiers)
				{
					<div @key="@pair.Key" class="d-flex flex-wrap flex-md-nowrap mb-1" style="border-bottom: 2px solid; border-color: @(pair.Value.color)!important;">
						<div class="d-flex m-1 flex-column text-center justify-content-center mx-auto col-12 col-sm-3 py-1 py-sm-1 py-md-auto">
							<input type="text" value="@pair.Value.name" class="rounded fs-2 py-md-auto py-1 m-0 text-center flex-fill col-12 text-wrap text-light" @onchange="(e) => ChangeTierName(e.Value?.ToString(), pair.Value.ogname)" placeholder="Tier Title" style="background-color: @pair.Value.color">
						</div>
						<div class="col-12 col-md-9 m-1 d-flex flex-row flex-fill">
							@if (false) // TODO: the mudcolorpicker takes a while to loadon mobile, but input color is janky as well
							{
								<div class="col-6 d-flex flex-fill">
									<h5 class="mx-1">Color: </h5>
									<input type="color" value="@pair.Value.color" />	
								</div>
							}
							else
							{
								<MudColorPicker Label="Tier Color" @bind-Text="pair.Value.color" Style="@($"color: {pair.Value.color};")" Placeholder="Select Color" Class="col-6" />
							}
							<button class="mx-2 bg-danger my-2 px-1 rounded col-3 " @onclick="YouSure">Remove</button>
						</div>
					</div>
				}
			</div>
		</div>
		@if (yousure)
		{
			<div class="maiedal d-flex flex-column text-center justify-content-center">
				<div class="p-0 p-md-2 darken-95 d-flex rounded text-center flex-column justify-content-center mx-auto text-light col-6">
					<h5> Are you sure you want to permanently remove this tier? All items will be deleted with it!</h5>
					<div class="d-flex flex-row flex-wrap mx-auto">
						<button class="mx-2 text-light" @onclick="YouSure">No</button>
						<button class="mx-2 text-danger" @onclick="DeleteTier">Yes, remove it and all items within</button>
					</div>
				</div>
			</div>
		}
	}
</div>
<div id="drag-ghost-container"></div>

<script src="imageHandler.js"></script>
<script>
	window.getTierItemIdAtPoint = (x, y) => {
		const el = document.elementFromPoint(x, y);
		return el?.closest("[data-tieritem-id]")?.dataset.tieritemId ?? null;
	};

	window.getTierIdAtPoint = (x, y) => {
		const el = document.elementFromPoint(x, y);
		return el?.closest("[data-tier-id]")?.dataset.tierId ?? null;
	};

	window.dragGhost = {
		ghost: null,

		create: function (element, x, y) {
			this.remove();

			const rect = element.getBoundingClientRect();
			const clone = element.cloneNode(true);

			clone.style.position = "fixed";
			clone.style.left = rect.left + "px";
			clone.style.top = rect.top + "px";
			clone.style.width = rect.width + "px";
			clone.style.height = rect.height + "px";
			clone.style.pointerEvents = "none";
			clone.style.opacity = "0.8";
			clone.style.zIndex = "9999";
			clone.style.transform = "scale(1.05)";
			clone.style.transition = "none";
			clone.style.willChange = "transform";

			document.body.appendChild(clone);

			this.ghost = clone;
		},

		move: function (x, y) {
			if (!this.ghost) return;

			this.ghost.style.left = (x - this.ghost.offsetWidth / 2) + "px";
			this.ghost.style.top = (y - this.ghost.offsetHeight / 2) + "px";
		},

		remove: function () {
			if (this.ghost) {
				this.ghost.remove();
				this.ghost = null;
			}
		}
	};
</script>


@code
{
	[Parameter]
	public required TierList selected { get; set; }

	[Parameter]
	public TierLister? tl { get; set; } = null!;

	[Parameter]
	public EventCallback OnSave { get; set; }

	[Parameter] 
	public EventCallback<string> OnExport { get; set; }

	[Parameter]
	public EventCallback<string> OnError { get; set; }

	Tier? selectier;

	TierItem? selecitem;
	string selecitemtier = "";
	string selecitemtags = "";

	bool yousure;

	bool TierEdit;

	[Parameter]
	public bool showcase { get; set; }
	[Parameter]
	public bool minimal { get; set; }
	[Parameter]
	public bool NoImg { get; set; }

	bool mobile;

	protected override async Task OnInitializedAsync()
	{
		mobile = OperatingSystem.IsAndroid() || OperatingSystem.IsIOS();
	}

	string filter = "";
	string temptiername = "";
	//ElementReference temptier;

	string overtier = ""; // which tier mouse is over
	//string draggedtier = ""; // which tier dragged item was from

	void Toggle(ref bool thing)
	{
		thing = !thing;
	}

	string GetFontSize(string name)
	{
		double size;
		if (name.Length > 8)
		{
			size = (1 - (((double)name.Length + 1) / (name.Length + 1.5))) * 400;
		}
		else
		{
			size = 30;
		}
		if (minimal)
			size *= 0.7;
		return $"font-size: {size.ToString("F2", CultureInfo.InvariantCulture)}px";
	}

	bool InFilter(string name)
	{
		if (filter == "")
		{
			return true;
		}
		string[] filters = filter.Split("+");
		foreach (string f in filters)
		{
			if (name.Contains(f, StringComparison.OrdinalIgnoreCase))
			{
				return true;
			}
		}
		return false;
	}

	ICollection<TierItem> GetFilteredItems(Tier tier)
	{
		if (string.IsNullOrEmpty(filter)) return tier.items;
		// return a materialized list -- Virtualize performs better with IList-ish sources.
		return tier.items.Where(x => InFilter(x.name)).ToList();
	}

	void Select(TierItem l)
	{
		Select(l, l.parent.ogname);
	}

	void Select(TierItem i, string key)
	{
		//Logger.LogInformation($"Youre showcase is: Damn {showcase}");
		if (mobile && showcase) return; // So they don't edit accidentally when scrolling
		selecitem = i;
		selecitemtier = key;
		for (int j = 0; j < i.tags.Length; j++)
			selecitemtags += i.tags[j] + (j != i.tags.Length-1 ? ", ":"");
		selectier = null;
	}

	void SelectTier(MouseEventArgs e, string tier)
	{
		Logger.LogInformation("Clicked tier " + tier);
		Logger.LogInformation(e.Button.ToString());
		if (e.Button == 2)
		{
			Logger.LogInformation("Registered tier " + tier);
			selectier = selected.tiers[tier];
			selecitem = null;
			selecitemtier = "";
		}
	}

	async Task UpdateTags()
	{
		if (selecitem == null) return;
		string[] tags = selecitemtags.Split(',');
		for (int i = 0; i < tags.Length; i++)
			tags[i] = tags[i].Trim();
		selecitem.tags = tags;		
	}

	async Task Exit()
	{
		selecitem = null;
		selectier = null;
		TierEdit = false;
		selecitemtier = "";
		selecitemtags = "";

		await TrySave();
	}

	async Task Add(string key)
	{
		TierItem temp = new TierItem("NEW ITEM,", selected.tiers[key]);
		selected.tiers[key].Add(temp);
		selecitem = temp;
		await TrySave();
	}

	async Task NewTier()
	{
		selected.tiers.Add("New Tier", new Tier("New Tier", "#EAD21F"));
		await TrySave();
	}

	async Task ChangeTierName(Tier tier)
	{
		await ChangeTierName(tier.name, tier.ogname);
	}

	async Task ChangeTierName(string? neww, string old)
	{
		Logger.LogInformation($"{neww}");
		if (String.IsNullOrEmpty(neww)) return;
		Tier? temp = selected.tiers[old];
		selected.tiers.Remove(old);

		while (true)
		{
			try
			{
				selected.tiers.Add(neww, temp);
				break;
			}
			catch
			{
				neww += " (1)";
			}
		}
		temp.name = neww;
		temp.ogname = neww;
		temp = null;
		await TrySave();
	}

	void ChangeTierName(ChangeEventArgs e, string old)
	{
		if (temptiername != "")
			ChangeTierName(temptiername, old);
		temptiername = "";
	}

	async Task StoreTierName(ChangeEventArgs e)
	{
		//temptiername = neww;
		string h = await JSRuntime.InvokeAsync<string>("getPlainText", temptiername);
		Logger.LogInformation(h);
	}

	async Task TrySave()
	{
		Logger.LogInformation("Saving!");
		if (tl != null)
			await tl.SaveAll();
		await OnSave.InvokeAsync();
	}

	void YouSure()
	{
		yousure = !yousure;
	}

	async Task Export()
	{
		var json = TierLister.ExportJson(selected);
		if (string.IsNullOrEmpty(json))
		{
			await OnError.InvokeAsync("Couldn't export tierlist: no JSON produced from TierService.tl.ExportJson()");
			return;
		}

		try
		{
			#if ANDROID || WINDOWS || IOS || MACCATALYST
	// Use native MAUI clipboard when running as a MAUI app (Android, Windows, iOS, MacCatalyst).
	await Clipboard.SetTextAsync(json);
			#else
			// Fallback for browser/web: use navigator.clipboard via JS interop.
			await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", json);
			Logger.LogInformation("exported by fallback.");
			#endif
			Logger.LogInformation("Exported JSON copied to clipboard.");
			await OnExport.InvokeAsync(json);
		}
		catch (Exception ex)
		{
			Logger.LogError(ex, "Failed to copy exported JSON to clipboard using primary method.");
			// Try the other approach as a best-effort fallback.
			try
			{
				await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", json);
				Logger.LogInformation("Fallback: exported JSON copied to clipboard via JS.");
			}
			catch (Exception jsEx)
			{
				Logger.LogError(jsEx, "Fallback copy to clipboard via JS also failed.");
				await OnError.InvokeAsync("Failed to export Tierlist into the clipboard");
			}
		}
	}

	async Task Delete()
	{
		if (selecitem == null) return;
		selected.tiers[selecitemtier].items.Remove(selecitem);
		selecitem = null;
		selecitemtier = "";
		YouSure();
		await TrySave();
	}

	async Task DeleteTier()
	{
		if (selectier == null) return;
		selected.tiers.Remove(selectier.ogname);
		selectier = null;
		YouSure();
		await TrySave();
	}

	async Task StopDrag()
	{
		//Logger.LogInformation("Overtier: "+overtier);
		var dragged = DragDropApi<TierItem>.GetDragged();
		if (dragged == null)
		{
			Logger.LogInformation("Couldn't perform dragdrop Operation: No Dragged Item found!!");
			return;
		}
		var over = DragDropApi<TierItem>.GetOver();


		if (!String.IsNullOrEmpty(overtier) && selected.tiers.ContainsKey(overtier))
		{
			var OverTier = selected.tiers[overtier];
			if (over != null)
			{
				if (over == dragged && over.parent != OverTier) // fallback
				{
					Logger.LogInformation("Unrecognised OverItem Fallback DragDrop");
					dragged.parent = OverTier;
					OverTier.Add(dragged);
					DragDropApi<TierItem>.GetDraggedList()!.Remove(dragged);
					DragDropApi<TierItem>.StopDrag(DragDropBehaviour.Cancel);
				}//*/
				else
				{
					Logger.LogInformation("Regular tieritem DragDrop!");
					if (!DragDropApi<TierItem>.StopDrag(DragDropBehaviour.Insert)) Logger.LogInformation("DragDop Failed: Recognised items, but failed operation");
					else
					{
						var temp3 = dragged.parent;
						dragged.parent = over.parent;
						over.parent = temp3;
					}
				}


			}
			else //if (dragged == over || over.parent != selected.tiers[overtier])
			{
				// DragDropApi<TierItem>.GetOver().parent != selected.tiers[overtier] && selected.tiers[overtier].items.Count <= 0  it just failed to remove the dragover item, so going to the tierlist is priority
				Logger.LogInformation("Regular Tier-Based DragDrop!");
				//Logger.LogInformation(DragDropApi<TierItem>.GetOver().parent.name + " != " + selected.tiers[overtier].name);
				var tempdragged = DragDropApi<TierItem>.GetDragged();
				//Logger.LogInformation("Got Dragged");
				var overlist = selected.tiers[overtier];
				Logger.LogInformation($"got list {overlist.name}");
				overlist.items.Add(new TierItem("you shouldn't be seeing this,", overlist));
				//Logger.LogInformation("Added dummy element");
				DragDropApi<TierItem>.OverHere(overlist.items, overlist.items.Count - 1);
				//Logger.LogInformation("Forced over dummy element");
				if (!DragDropApi<TierItem>.StopDrag(DragDropBehaviour.Replace))
				{
					Logger.LogInformation("Failed tier item swap");
				}
				else 
					tempdragged!.parent = overlist;

				//Logger.LogInformation(overlist.AsString());

			}
		}
		else if (over != null)
		{
			if (!DragDropApi<TierItem>.StopDrag(DragDropBehaviour.Insert))
				Logger.LogInformation("DragDrop Failed: Couldn't recognise over tier, and failed fallback method");
			else Logger.LogInformation("Fallback Tier-Based DragDrop");
		}
		else
		{
			Logger.LogInformation("DragDrop Failed: Couldn't recognise Overtier nor Over item");
		}
		await TrySave();
		if (mobile)
		{
			await JSRuntime.InvokeVoidAsync("dragGhost.remove");
			if (DragDropApi<TierItem>.GetOver() != null)
			{
				Logger.LogInformation("Over Item is still " + DragDropApi<TierItem>.GetOver()!.name);
				DragDropApi<TierItem>.StopDrag(DragDropBehaviour.Cancel);
			}
		}
		overtier = "";
		StateHasChanged();


	}

	async Task OnPointerMove(PointerEventArgs e, KeyValuePair<string, Tier> pair) // Mobile only implementation
	{
		if (DragDropApi<TierItem>.GetDragged() == null || !mobile) return;

		//Logger.LogInformation("Still draggin " + DragDropApi<TierItem>.GetDragged().name);

		//Logger.LogInformation($"Pointer moved at {e.ClientX}, {e.ClientY}");

		var overId = await JSRuntime.InvokeAsync<string>(
			"getTierItemIdAtPoint",
			e.ClientX,
			e.ClientY
		);

		var overTierId = await JSRuntime.InvokeAsync<string>(
			"getTierIdAtPoint",
			e.ClientX,
			e.ClientY
		);

		await JSRuntime.InvokeVoidAsync(
			"dragGhost.move",
			e.ClientX,
			e.ClientY
		);

		if (overTierId == null)
		{
			if (!String.IsNullOrEmpty(overtier))
				overtier = "";
		}
		else if (overtier != overTierId && DragDropApi<TierItem>.GetDragged() == null) // Have to recheck for async reasons
		{
			Logger.LogInformation($"Pointer is over Tier id: {overTierId}");
			OverTier(overTierId);
		}

		if (overId == null)
		{
			if (DragDropApi<TierItem>.GetOver() != null)
				DragDropApi<TierItem>.OuttaHere();
		}
		else
		{
			var idx = int.Parse(overId);

			if (DragDropApi<TierItem>.GetOverIndex() == idx || DragDropApi<TierItem>.GetDragged() == null) // Have to recheck for async reasons
				return;

			Logger.LogInformation($"Pointer is over TierItem id: {overId} (which is in Tier {overTierId} )");

			//currentOverIndex = idx;

			// IMPORTANT:
			// Virtualize means idx maps to the tier list you passed into TierItemComp
			// so this is safe
			if (String.IsNullOrEmpty(overtier))
				DragDropApi<TierItem>.OverHere(pair.Value.items, idx);
			else
				DragDropApi<TierItem>.OverHere(selected.tiers[overtier].items, idx);
		}

		
	}

	void OverTier(string tier)
	{
		Logger.LogInformation($"Mouse over {tier} tier!");
		overtier = tier;
		StateHasChanged();
	}

	void OuttaTier(MouseEventArgs e)
	{
		//Logger.LogInformation($"Mouse out (tier)!");
		overtier = "";
		StateHasChanged();
	}

	void DropIntoTier(string Tier)
	{
		Logger.LogInformation($"Mouse dropped over {Tier} tier!");
		overtier = Tier;
		if (mobile) StopDrag();
		StateHasChanged();
	}

	public void Dispose()
	{
		selectier = null;
		selecitem = null;
	}
}